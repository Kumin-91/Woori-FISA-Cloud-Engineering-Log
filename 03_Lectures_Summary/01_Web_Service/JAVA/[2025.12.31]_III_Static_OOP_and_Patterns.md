# 객체 지향 (OOP) & Singleton 패턴

## 1. 객체 지향 (OOP)

### 1.1 객체 지향의 장점 및 설계 철학

* 데이터와 기능의 명확한 분리: 유지보수성을 위해 데이터 저장용 객체와 로직 처리용 객체를 구분합니다.

* 성능 최적화: 기능 중심의 클래스는 불필요한 객체 생성을 막기 위해 싱글톤 (Singleton) 패턴을 적용하거나 모든 메소드를 `static`으로 설계하여 메모리 효율을 높입니다.

### 1.2 객체 생성 메커니즘 (부모-자식 순서)

* Root 클래스: java.lang.Object는 모든 클래스의 최상위 부모이며, 명시적 상속이 없어도 자동 반영됩니다.

* 생성 순서: new 자식클래스() 호출 시, 메모리에는 부모 (Object 포함) 객체가 먼저 생성 및 초기화된 후 자식 객체가 생성됩니다.

### 1.3 상속 관계 (is a)

* 정의: "자식은 부모이다"가 성립하는 관계입니다.

* 특징: extends 키워드를 사용하며, 부모의 멤버(변수, 메소드)를 자식이 물려받아 재사용합니다.

```Java
class A2 extends Object {
    String message = "fisa";
    A2() {
        super();
        //String message 객체 생성
        System.out.println("A");
    } //A 객체생성 완료
}

class B2 extends A2 {
    B2() {
        super();
        //A2 a = new A2(); 완벽 생성 및 초기화
        System.out.println("B");
    } //B 객체생성 완료
}
```

### 1.4 보유 관계 (has a)

* 정의: "클래스 내부에 다른 객체를 가지고 있다"는 관계입니다.

* 특징: 상속이 아닌 멤버 변수로 다른 클래스를 선언하여 사용하며, 설계의 유연성이 더 높습니다.

```Java
class A extends Object {
    String message = "fisa";
    A() {
        super();
        //String message 객체 생성
        System.out.println("A");
    } //A 객체생성 완료
}

class B extends Object {
    A a = new A();
    B() {
        super();
        //A a = new A(); 완벽 생성 및 초기화
        System.out.println("B");
    } //B 객체생성 완료
}
```

## 2. 생성자 (Constructor)

* 주 목적: 객체 생성 시 멤버 변수 초기화 및 필수 실행 로직 수행을 담당합니다.

* 특징: 클래스에는 반드시 하나 이상의 생성자가 존재해야 하며, 개발자가 미작성 시 컴파일러가 기본 생성자(Default Constructor)를 자동 생성합니다.

* 문법: class명과 일치하게 작성

```Java
class testClass {
    //생성자
    testClass() {
        //초기화 및 필수 실행 로직
    }
}
```

* 제약 사항: private 생성자를 선언하면 외부에서 new를 통한 객체 생성을 강제로 금지할 수 있습니다. (싱글톤 패턴의 핵심)

## 3. static (정적 멤버)

* 메모리 로딩 시점: 바이트코드가 실행 엔진에 로드되는 시점에 Method 영역에 실체화되며, 객체 생성 없이도 즉시 사용 가능합니다.

* 공유 자원: 생성되는 모든 객체가 동일한 메모리 주소를 공유하여 사용합니다.

* 설계 판단 기준:

    * Instance: 특정 객체의 데이터 (상태)를 기반으로 동작해야 하는 경우.

    * Static: 전달받은 데이터만 처리하거나 공통 기능을 제공하는 경우 (예: Math 클래스, parseInt() 등).

* static 메소드 예: java.lang.Math

    * 제공받은 library 혹은 API입니다.

    * 모든 메소드는 static이며, 변수는 불변값인 final 상수로만 구성되어 있어 객체 생성이 필요 없는 대표적인 유틸리티 클래스입니다.

### Q. static 적합 여부 판단해보기

#### 1. String 클래스의 length() 설계

```Java
//1번.
public int length() { 문자열 객체 길이값 반환 }
//2번.
public static int length() { 문자열 객체 길이값 반환 }
//3번.
public static int length(String data) { 문자열 객체 길이값 반환 }
```

```Java
//문자열 객체 자동 생성 (new 생성자 조합 없이도)
String data = “fisa”;
//1번. 4값 반환
System.out.println(data.length());
//2번. ???
System.out.println(String.length());
//3번. 4값 반환
System.out.println(String.length(data));
```

* 1번: `String` 객체는 자신이 가진 문자열 데이터를 내부에 품고 있습니다. 객체가 가진 문자열의 길이를 알려달라는 의미로 인스턴스 메소드가 가장 적합합니다.

* 2번: `static`은 객체 없이 호출되는데, 측정할 데이터가 없습니다. `String.length()`라고 부르면 누구의 길이를 잴지 알 수 없으므로 설계가 불가능합니다.

* 3번: 외부에서 데이터를 넘겨받으므로 논리적으로는 가능합니다. 하지만 자바는 객체 지향 언어이므로, 데이터와 기능을 하나로 묶는 1번 방식을 더 선호합니다.

#### 2. Integer.parseInt(String data)

```Java
public static int parseInt(String data) {
	return 받은 데이터 정수 int로 반환해서;
}
```

* 외부에서 문자열을 받아 단순히 숫자로 바꾸는 기능만 수행합니다.

* 이 메소드는 클래스 내부에 저장된 데이터를 사용하지 않으므로 객체 생성이 의미가 없으며, `static`으로 설계하는 것이 성능과 사용성 면에서 완벽합니다.

#### 3. 웹 서버 성능 최적화를 위한 객체 관리 전략

* 웹 서버 환경에서는 수많은 요청이 동시에 발생하므로, 불필요한 객체 생성은 메모리 부족과 가비지 컬렉션 부하로 이어져 실행 성능을 저하시킵니다. 이를 방지하기 위해 객체 수를 강제적으로 조율하는 설계가 필요합니다.

* A. 의미 없는 객체 생성의 강제 금지
    * 특정 기능을 수행할 때마다 new를 통해 객체를 만드는 행위가 시스템 자원을 낭비한다고 판단될 경우 이를 원천 차단합니다.

* B. 개발 방법 및 전략
    * 생성자 호출 제약: 생성자를 `private`으로 선언하여 외부 클래스에서 `new` 키워드로 인스턴스를 생성하는 것을 방지합니다.

    * 유틸리티 클래스 방식: 모든 메소드를 `static`으로 선언하여 객체 생성 없이 클래스명으로만 기능을 제공합니다.

    * 인스턴스 공유 방식 (Singleton): 클래스 내부에서 단 하나의 객체만 생성되도록 보장한 후, 일반 인스턴스 메소드를 통해 해당 객체의 기능을 공유합니다.

* C. **싱글톤 디자인 패턴 (Singleton Design Pattern)**

    * **정의: 애플리케이션이 시작될 때 어떤 클래스가 단 한 번만 메모리를 할당하고 그 메모리에 인스턴스를 만들어 사용하는 디자인 패턴입니다.**

    * **핵심 이점: 고정된 메모리 영역을 사용하므로 메모리 낭비를 방지하고, 데이터 공유가 쉽습니다.**

## 4. 외부 라이브러리 환경 세팅 도구 (Build Tool)

개발에 필요한 외부 라이브러리를 수동으로 다운로드하고 관리하는 번거로움을 해결하기 위한 도구입니다.

* 핵심 기능: 라이브러리의 이름과 버전 정보만 설정 파일에 명시하면, 중앙 저장소로부터 해당 라이브러리와 그에 의존하는 파일들까지 자동으로 다운로드하여 프로젝트에 포함합니다.

* 주요 도구:

    * **Maven: XML 기반 (pom.xml)의 설정 방식을 사용하며, 가장 널리 쓰이는 표준 빌드 도구입니다.**

    * Gradle: Groovy나 Kotlin DSL 기반으로 설정이 유연하고 빌드 속도가 빨라 현대적인 프로젝트에서 선호됩니다.

* IDE 지원: VS Code, IntelliJ, Eclipse 등 주요 IDE에 플러그인 형태로 내장되어 있어 편리하게 사용할 수 있습니다.

* 주요 라이브러리 사례 (Lombok): 반복적인 Getter/Setter, 생성자 코드를 어노테이션 하나로 자동 생성해 주는 도구로, 빌드 도구를 통해 손쉽게 추가 가능합니다.