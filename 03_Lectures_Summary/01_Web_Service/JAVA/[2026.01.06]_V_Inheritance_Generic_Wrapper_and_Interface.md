# Inheritance, Generic, Wrapper and Interface

**[1. Inheritance](#1-inheritance-상속)**

**[2. Generic and Wrapper class](#2-generic--wrapper-class)**

**[3. API Documents](#3-api-문서-표현법)**

**[4. Interface](#4-interface--추상화와-다형성)**

## 1. Inheritance (상속)

부모 클래스의 변수 및 메소드를 자식에게 물려주어 코드의 재사용성을 올리는 방법

### 1.1 상속이란?

* 원리: 자식 클래스는 부모의 모든 속성을 물려받아 자신의 것처럼 사용할 수 있습니다.

* 상속 불가 항목: 생성자 (`Constructor`)와 정적 블록 (`static {}`)은 클래스 고유의 자산이므로 자식에게 상속되지 않습니다.

* 장점: 코드 재사용성 향상 및 중복 제거

* 단점: 계층 구조가 복잡해질 경우 실행 시 메소드 탐색으로 인한 속도 저하 요인

* 예제: `Child` 클래스는 `Parent`를 상속받으며, `Parent`는 별도로 명시하지 않아도 자바의 최상위 클래스인 `Object`를 암시적 (Implicit)으로 상속받습니다.

    ```Java
    class Parent {
        String id;
        int age;
        //기본 생성자
        Parent() {}

        //클래스의 메소드
        void printAll()
        {
            System.out.println(id);
		    System.out.println(age);
        }
    }

    public class Child extends Parent {
	    String job;
        //기본 생성자
	    public Child() {}

	    //클래스의 메소드
	    void printAll() {
            System.out.println(job);
	    }
    }
    ```

* 생성 순서

    ```Java
    //id/age/job 변수 생성되는 순서?
    //Parent의 생성자 -> Child의 생성자
    //자식 생성자 첫 줄에는 항상 부모 생성자를 호출하는 super()가 생략되어 있음
    Child c = new Child();
    ```

### 1.2 Overriding (재정의) vs. Overloading (다중정의)

| 구분 | Overriding (재정의) | Overloading (다중정의) |
| --- | --- | --- |
| 관계 | 상속 관계 (부모-자식) | 동일 클래스 내부 |
| 규칙 | 이름, 반환타입, 파라미터가 100% 일치 | 이름은 같으나 파라미터가 다름 |
| 목적 | 상속받은 기능을 자식에 맞게 수정 및 확장 | 하나의 이름으로 다양한 형태의 호출 지원 |
| 팁 | `super.method()`를 통해 부모 로직 활용 가능 | 생성자 오버로딩이 대표적인 예시 |

 `@Override` : 개발자의 오타 (예: `printall`)를 컴파일러가 잡아주는 아주 중요한 안전장치

* 주의사항

    * 메소드에 `final`이 붙으면 재정의 (Overriding)가 불가능

    * 자식의 재정의 메소드는 부모의 메소드보다 더 좁은 범위의 접근 제어자 (예: `public` → `private`)를 가질 수 없음 (부모보다 더 넓은 범위는 허용됨)

* 예제: `Child` 클래스에서 부모의 `printAll()`을 재정의함

    ```Java
    //재정의
    @Override
	void printAll() {
		super.printAll(); //상속받은 부모 로직을 100% 적용
		System.out.println(job);
	}
    ```

### 1.3 Polymorphism (다형성)

"상위 타입의 변수는 모든 자손 객체를 수용할 수 있다"는 원리입니다.

* Is-a 관계: "자손은 조상이다"라는 논리가 성립합니다. (예: SmartPhone is a Phone)

* 활용: 부모 타입의 참조 변수 하나로 여러 형태의 자식 객체를 관리할 수 있어 유연한 설계가 가능해집니다.

### 1.4 `instanceof` 연산자

* 판별 기준

    * true 반환: 실제 객체가 물어본 타입이거나, 그 타입의 후손 (자식)일 때.

    * false 반환: 실제 객체가 물어본 타입보다 조상이거나, 상속 관계는 있지만 남남일 때.

    * 컴파일 에러: 비교하려는 두 클래스 사이에 상속 계통 (Hierarchy)상 접점이 전혀 없을 때.

* 참고: 동일성(==)과 동등성(equals)
    
    * `==` 연산자: 참조 타입의 경우 주소값 (객체의 위치)이 같은지 비교합니다.

    * `equals()` 메소드: 객체 내부의 내용값이 논리적으로 일치하는지 비교하기 위해 재정의하여 사용합니다.

* 최신 자바 버전에서는 `if (v0 instanceof B b)` 처럼 체크와 동시에 변수 선언이 가능

* 예제

    ```Java
    class A extends Object {}
    class B extends A {}
    class C extends Object {}

    public class InstanceofTest {
        public static void main(String[] args) {

            Object v0 = new A();
            A v1 = new A();
            A v2 = new B();
            B v3 = new B();
            Object v4 = new C();
            C v5 = new C();

            // == : 참조 타입은 주소값 비교, 기본타입은 값비교
            //instanceof : 참조 타입의 타입

            // v0의 실제 인스턴스는 A이며, A는 Object의 후손이므로 true
            System.out.println(v0 instanceof Object); 
            // v0의 실제 인스턴스는 A이므로 true
            System.out.println(v0 instanceof A); 
            // v0의 실제 인스턴스인 A는 B의 부모 타입이므로 B의 인스턴스가 아님 (false)
            System.out.println(v0 instanceof B); 
            // v0의 실제 인스턴스인 A는 C와 상속 관계가 없으므로 false
            System.out.println(v0 instanceof C); 
            // [컴파일 에러]: D 클래스가 정의되지 않아 심볼을 찾을 수 없음
            System.out.println(v0 instanceof D); 

            // 모든 클래스의 조상은 Object이므로 true
            System.out.println(v1 instanceof Object); 
            // v1의 실제 인스턴스는 A이므로 true
            System.out.println(v1 instanceof A); 
            // A 인스턴스는 B의 부모 타입일 뿐, B 타입은 아님 (false)
            System.out.println(v1 instanceof B); 
            // [컴파일 에러]: A와 C는 상속 계통(Hierarchy)에서 접점이 없으므로 비교 불가
            System.out.println(v1 instanceof C); 

            // B 인스턴스는 Object의 후손이므로 true
            System.out.println(v2 instanceof Object); 
            // B 인스턴스는 A를 상속받았으므로 A 타입이기도 함 (true)
            System.out.println(v2 instanceof A); 
            // v2의 실제 인스턴스는 B이므로 true
            System.out.println(v2 instanceof B); 
            // [컴파일 에러]: A 참조 타입과 C 클래스는 상속 관계가 전혀 없으므로 검사 불가
            System.out.println(v2 instanceof C); 

            // B 인스턴스는 Object의 후손이므로 true
            System.out.println(v3 instanceof Object); 
            // B 인스턴스는 A를 상속받았으므로 A 타입으로 간주될 수 있음 (true)
            System.out.println(v3 instanceof A); 
            // v3의 실제 인스턴스는 B이므로 true
            System.out.println(v3 instanceof B); 
            // [컴파일 에러]: B와 C는 상속 계통상 아무런 연관이 없으므로 비교 불가
            System.out.println(v3 instanceof C); 

            // C 인스턴스는 Object의 후손이므로 true
            System.out.println(v4 instanceof Object); 
            // 실제 인스턴스인 C는 A와 아무런 상관이 없음 (false)
            System.out.println(v4 instanceof A); 
            // 실제 인스턴스인 C는 B와 아무런 상관이 없음 (false)
            System.out.println(v4 instanceof B); 
            // v4의 실제 인스턴스는 C이므로 true
            System.out.println(v4 instanceof C); 

            // C 인스턴스는 Object의 후손이므로 true
            System.out.println(v5 instanceof Object); 
            // [컴파일 에러]: C 참조 타입과 A 클래스는 상속 관계가 없으므로 비교 불가
            System.out.println(v5 instanceof A); 
            // [컴파일 에러]: C 참조 타입과 B 클래스는 상속 관계가 없으므로 비교 불가
            System.out.println(v5 instanceof B); 
            // v5의 실제 인스턴스는 C이므로 true
            System.out.println(v5 instanceof C);
        }
    }
    ```

### 1.5 Casting (형변환)

* 업캐스팅 (Up-casting): 자식 타입을 부모 타입으로 변환하는 것입니다.

    * 특징: 자식은 부모의 모든 특성을 포함하고 있으므로 (Is-a 관계), 별도의 연산자 없이 암시적 (Implicit)으로 안전하게 수행됩니다.

    * 효과: 여러 자식 객체를 하나의 부모 타입 배열이나 리스트로 관리할 수 있는 유연성을 제공합니다.

* 다운캐스팅 (Down-casting): 부모 타입을 자식 타입으로 변환하는 것입니다.

    * 특징: 부모 변수가 가리키는 실제 객체가 해당 자식 타입인지 보장할 수 없으므로, 반드시 명시적 (Explicit) 형변환 연산자를 사용해야 합니다.

    * 위험성: `instanceof` 체크 없이 강제 형변환을 시도할 경우, 런타임 에러인 `ClassCastException`이 발생하여 프로그램이 중단될 수 있습니다.

    * 안전한 사용: 반드시 `instanceof` 연산자로 타입을 확인한 후 형변환을 진행

        ```Java
        // 안전한 다운캐스팅
        if (v0 instanceof B) {
            B b = (B) v0;
        }
        ```

## 2. Generic & Wrapper Class

자바의 제네릭은 참조 타입(Reference Type)만 수용할 수 있기 때문에, 기본 타입(Primitive Type)을 객체화해 주는 Wrapper 클래스가 필수

### 2.1 Wrapper Class

기본 타입 8가지를 객체로서 다룰 수 있도록 지원하는 8개의 참조 타입 클래스입니다.

* Autoboxing: 기본 타입의 값을 참조 타입 변수에 대입할 때 자동으로 객체로 변환되는 현상입니다.

    * 예: `Integer i = 10;` (내부적으로 `Integer.valueOf(10)` 호출)

* Auto-unboxing: 참조 타입 객체를 기본 타입 변수에 대입하거나 연산할 때 자동으로 기본값으로 변환되는 현상입니다.

    * 예: `int n = i;` (내부적으로 `i.intValue()` 호출)

```Java
//jdk 1.5 부터 지원되는 문법
static void m1() {
	int i = 10; //기본 타입

    // 1. Unboxing (Auto)
    // int i2 = new Integer(3).intValue(); 와 동일
    // 주의: new Integer() 생성자는 JDK 9부터 Deprecated(사용 권장 안 함) 되었습니다.
    int i2 = new Integer(3);

    // 2. Autoboxing
    // Integer i3 = Integer.valueOf(30); 와 동일
    Integer i3 = 30;

	System.out.println(i + " " + i2);
	System.out.println(i3.toString()); // 객체이므로 메소드 호출 가능
}
```

### 2.2 Generic 문법

클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법으로, 타입 안정성 확보가 주 목적

* 형변환 (Casting) 생략: 데이터를 꺼낼 때마다 일일이 다운캐스팅 (Down-casting)을 할 필요가 없어 코드가 간결해집니다.

* 컴파일 시점 체크: 잘못된 타입의 데이터가 들어오는 것을 실행 전에 방지할 수 있습니다.

```Java
static ArrayList<String> m2() {
    // 1. Raw Type (제네릭 미사용): 모든 객체를 Object로 저장 (Up-casting 발생)
    ArrayList al1 = new ArrayList();
    al1.add("abc");
    al1.add(new Customer("승환", 28));

    // 2. Generic (제네릭 사용): String 타입만 저장 가능하도록 제한
    ArrayList<String> al2 = new ArrayList<>();
    al2.add("민채");

    // [비교] 0번째 데이터의 첫 글자 출력

    // al1: Object를 반환하므로 String 메소드 사용을 위해 반드시 강제 형변환 필요
    System.out.println(((String) al1.get(0)).charAt(0)); 

    // al2: 이미 String임을 보장받으므로 형변환 없이 즉시 메소드 호출 가능
    System.out.println(al2.get(0).charAt(0)); 
    
    return al2;
}
```

## 3. API 문서 표현법

* 관련 라이브러리: `java.lang`, `java.util` 패키지 내 자료구조 및 라이브러리 지원 클래스들

* 표현의 목적: Object 타입을 보다 구체적이고 명확하게 표현한 방식 (JDK 버전업에 따라 코드에 타입 명확성을 부여하고, 동적 타입 제약을 통한 안정성 확보)

* 주요 타입 기호

    * `<E>` (Element): 요소(데이터) / HTML과 XML 문법에서 태그 자체를 의미하는 '엘리먼트'와 유사한 개념

    * `<K>` (Key): 키(Key)

    * `<V>` (Value): 값(Value)

    * `<T>` (Type): 타입(Type)

## 4. `Interface` : 추상화와 다형성

* 인터페이스는 미완성 메소드(추상 메소드)로만 구성되어 객체의 규격을 정의합니다.

* 특징: 실제 객체 생성이 불가능하며, 타입으로 사용되어 하위 클래스 구현을 강제합니다.

* `@FunctionalInterface` : 단 하나의 추상 메소드만 가져서 람다식으로 구현 가능한 인터페이스임을 명시합니다.

* 예제

    ```Java
    @FunctionalInterface
    interface Calc {
        // 암시적으로 public abstract 가 붙음
        int oper(int v1, int v2);
    }
    ```

### 4.1 구현 클래스 개발과 호출 (전통적 방식)

인터페이스를 상속받아 미완성 기능을 완벽하게 구현하는 방식입니다.

```Java
// 1. 하위 클래스 개발
class CalcImpl implements Calc {
    @Override
    public int oper(int v1, int v2) {
        return v1 + v2;
    }
}

// 2. 객체 생성 및 메소드 호출
Calc operation = new CalcImpl();
System.out.println(operation.oper(2, 8)); // 10
```

* 단점 : + 만 가능한 클래스, - * / 추가로 또 개발해야 하는 이슈 발생

### 4.2 익명 클래스와 람다식 (현대적 방식)

부득이하게 구현체 (Implementation) 클래스가 없거나 일회성 로직이 필요할 때 직접 객체 생성과 구현을 동시에 처리합니다.

* 표현 방식
    
    * ( parameters ) -> expression body
    
    * ( parameters ) -> { expression body }
    
    * () -> { expression body }
    
    * () -> expression body
    
* 예제

    ```Java
    public static void main(String[] args) {
        // 1. 람다식 (Lambda): 핵심 로직만 간결하게 표현
        Calc c = (v1, v2) -> v1 * v2;
        System.out.println(c.oper(10, 20)); //200

        c = (v1, v2) -> { 
            return v1 / v2;
        };
        System.out.println(c.oper(100, 20)); //5

        // 2. 익명 구현 클래스: 클래스 선언 없이 즉석에서 구현
        Calc operPlus = new Calc() {
            public int oper(int v1, int v2) {
                return v1 + v2;
            }
        };
        System.out.println(operPlus.oper(10, 20)); //30
    }
    ```

## 5. 더블 연산자(::) & 람다식 활용

컬렉션 데이터를 처리할 때 람다와 메소드 참조를 통해 코드를 극적으로 줄일 수 있습니다.

```Java
public static void main1(String[] args) {
    List<People> datas = Arrays.asList(
        new People("재석", 50),
        new People("연아", 30),
        new People("동엽", 60)
    );

    // Step 01: 전통적인 for-each 문
    for (People p : datas) {
        System.out.println(p);
    }

    // Step 02: 더블 연산자 (Method Reference)
    // 파라미터 전달 로직이 명확할 때 System.out::println 으로 생략 가능
    datas.forEach(System.out::println);

    // Step 03: -> 표기로 구현하는 람다식
    // 각 요소 v를 받아 출력 메소드에 전달함
    datas.forEach(v -> System.out.println(v));
    //이름만 출력
    datas.forEach(v -> System.out.println(v.toString()));   
}
```