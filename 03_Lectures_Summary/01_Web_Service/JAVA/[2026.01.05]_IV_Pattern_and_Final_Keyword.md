# MVC 패턴 / Builder 패턴 / Final Keyword / enum

## 1. MVC Pattern

모든 현대적 웹 서비스 아키텍처의 근간이 되는 디자인 패턴입니다.

### 1.1 M: Model (Biz Logic & Data)

* 역할: 실제 비즈니스 로직 처리 및 데이터 관리 (DB).

* 특징: 화면이나 제어 흐름에 관여하지 않고 오직 "데이터를 어떻게 처리할 것인가"에만 집중합니다.

### 1.2 V: View (UI/UX)

* 역할: 사용자에게 정보를 보여주고 입력을 받는 화면.

* 실습: StartView (요청)와 EndView (결과)로 분리하여 처리.

### 1.3 C: Controller (Orchestrator)

* 역할: View로부터 요청을 받아 Model에게 일을 시키고, 결과를 다시 View로 전달하는 중재자.

* Spring: `@Controller` 어노테이션을 통해 특정 URL 요청을 어떤 로직으로 연결할지 결정합니다.

### 1.4 Standalone Application vs. Framework

* Standalone Application: 별도의 외부 서버 없이 독자적으로 실행되는 애플리케이션입니다.

    * 자바의 `public static void main(String[] args)` 메소드를 시작점으로 가집니다.

* Spring Boot (Special Case)

    * 전통적인 웹 애플리케이션과 달리 main 메소드를 보유하며 Standalone 형태로 실행됩니다.

    * 내장 웹 컨테이너를 포함하고 있어, 별도의 서버 설치 없이 즉시 웹 서비스를 구동할 수 있는 특별한 구조입니다.

* Legacy Spring Framework

    * 프로젝트 자체에 main 메소드가 없으며, 외부 웹 컨테이너에 배포가 되어야만 구동이 가능합니다.

### 1.5 실습 아키텍처 (MVC Flow)

콘솔 환경에서 브라우저와 DB가 존재한다고 가정한 데이터 흐름입니다.

| 순서 | 구성 요소 | 역할 및 흐름 설명 |
| --- | --- | --- |
| 0 | Customer.java | [Data] 데이터 저장소. DTO(Data Transfer Object), VO(Value Object), Java Bean |
| 1 | StartView.java | [Request] 모든 사용자 요청의 시작점 (가상 브라우저). 입력을 받아 Controller로 전달. |
| 2 | Controller.java | [Routing] 요청을 수신하고, 어떤 비즈니스 로직(Model)을 호출할지 결정 및 중재. |
| 3 | Model.java | [Process] 실질적인 데이터 처리 수행. (가상 DB와 소통하며 CRUD 작업 수행) |
| 4 | Controller.java | [Result Handling] Model로부터 처리 결과를 전달받아 출력 화면 (View)을 결정. |
| 5 | EndView.java | [Response] 최종 처리 결과를 콘솔에 출력하여 사용자에게 응답 완료. |

## 2. Builder Pattern

객체 생성 시 생성자 인자의 순서나 개수에 구애받지 않고, 가독성 높고 유연하게 객체를 생성하기 위한 패턴입니다.

### 2.1 Builder Pattern 적용하기 (Lombok 활용)

Lombok의 `@Builder` 어노테이션을 사용하면 복잡한 빌더 클래스를 직접 구현하지 않아도 컴파일 시점에 자동으로 생성됩니다.

```Java
import lombok.Builder;
import lombok.ToString;

@Builder
@ToString // 객체 정보 출력을 위해 추가
public class People {
    private String name;
    private int age;
    private String id;
    private String pw;
}
```

### 2.2 Builder Pattern 사용 예제

1. `People.builder()`: `PeopleBuilder`라는 내부 보조 객체를 생성하여 반환합니다.

2. `.id("user01")`: `PeopleBuilder` 객체 내부의 `id` 필드 값을 채운 뒤, 다시 자기 자신 (`PeopleBuilder`)을 반환합니다. 계속해서 `.pw()` 등을 연결할 수 있습니다.

3. `.build()`: 지금까지 채워진 설정값을 바탕으로 `People` 객체를 생성하여 반환합니다.

    ```Java
    public class PeopleTest {
        public static void main(String[] args) {
            //user01이라는 id만 초기화된 People 객체 생성
            People p1 = People.builder().id("user01").build();
            /* 메소드 체인(Method Chain)
             * People.builder()
             *  : static 메소드, 클래스 명으로 호출 가능
             *  : 반환 값이 PeopleBuilder 객체
             * 
             * People.builder().id("user01")
             *  : PeopleBuilder 클래스 내부에서 id변수값 수정하는 메소드
             *  : non-static 메소드, PeopleBuilder 객체 통해서만 호출 가능
             *  : People.builder() 반환 값이 PeopleBuilder 객체
             * 
             * People.builder().id("user01").build();
             *  : PeopleBuilder 내부에서 제공되는 메소드
             *  : 반환 값은 People 객체
            */
            System.out.println(p1.getId());

            //? id: user02, pw: 22라는 값을 보유한 People 객체 생성
            People p2 = People.builder().id("user02").pw("22").build();
            System.out.println(p2);
        }
    }
    ```

## 3. Final Variable

### 3.1 명명 규칙

* `static final`로 선언된 상수는 값이 변하지 않는 전역적인 정의입니다.

* 일반 변수와 구분하기 위해 SNAKE_CASE를 사용합니다.

* 예: `CAR_NAME`, `PERSON_ID`

### 3.2 final 키워드의 특징

* 변수: 초기화 후 값 변경이 불가능한 상태가 됩니다.

* 상수화: `static final`을 결합하여 메모리에 단 하나만 존재하며 어디서든 참조 가능한 변경 불가능한 값을 정의합니다.

    ```Java
    public class FinalVariable {
        //상수 선언
        public static final String MSG = "fisa";

        public static void main(String[] args) {
            System.out.println(MSG);

            //값 변경 불가능
            //MSG = "ce;
        }
    }
    ```

### 3.3 생각해볼점: 상수 정의의 한계와 위험성

* 타입 안정성 부족: `status` 변수는 `String` 타입이므로, 개발자가 실수로 `"Started"` (대소문자 오타)나 `"100"` (엉뚱한 값)을 넣어도 컴파일러는 이를 잡아내지 못합니다.

    ```Java
    public class FinalProcessTest {
        // 1. 상수 정의 (열거형 대신 static final 사용)
        public static final String STARTED = "STARTED";
        public static final String COMPLETED = "COMPLETED";
        public static final String FAILED = "FAILED";

        public static void main(String[] args) {
            // 2. 정상적인 할당
            String status = STARTED;
            System.out.println("Current status: " + status);

            // 3. 컴파일 에러가 발생하지 않는 위험한 상황
            //아래 코드들은 문법적으로 'String'이므로 컴파일 에러가 발생하지 않습니다.
            //status = "Started";
            //status = "100";

            // 4. 정상적인 할당
            status = COMPLETED;
            System.out.println(status);

            // 5. 조건문 활용 예시
            if (status.equals(STARTED)) {
                System.out.println("프로세스가 시작되었습니다.");
            }
        }
    }
    ```

## 4. enum

위의 3.3의 상황을 해결하기 위해 등장한 것이 바로 `enum`입니다.

### 4.1 enum 정의 및 적용

```Java
//정해진 값 외에는 아예 할당 불가능
enum ProcessStatus {
	STARTED, COMPLETED, FAILED
}
```

### 4.2 enum의 장점

* 컴파일 타임 체크: `ProcessStatus status = "STARTED";` 라고 입력하면 컴파일 에러가 발생합니다. 반드시 `ProcessStatus.STARTED`로만 값을 넣어야 합니다.

* 가독성 및 의도 명확: 이 변수가 가질 수 있는 값의 범위를 클래스 구조 안에서 한눈에 파악할 수 있습니다.

    ```Java
    //열거형 정의
    enum ProcessStatus {
    	STARTED, COMPLETED, FAILED
    }
    
    public class EnumProcessTest {
    	public static void main(String[] args) {
    		// 1. 정상적인 할당
    		ProcessStatus status = ProcessStatus.STARTED;
    		System.out.println("Current status: " + status);
    
    		// 2. 컴파일 에러 발생 예시
            //status = "Started";
    
            // 3. 정상적인 할당
            status = ProcessStatus.STARTED;
    
    		// 4. 조건문 활용 예시
    		if (status == ProcessStatus.STARTED) {
    			System.out.println("프로세스가 시작되었습니다.");
    		}
    	}
    }
    ```