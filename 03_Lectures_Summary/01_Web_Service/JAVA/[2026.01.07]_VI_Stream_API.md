# Stream API

### model.domain.People

```Java
//Annotation 생략
public class People {
    private String name;
    private int age;
}
```

### 1. Stream API란?

배열이나 컬렉션 (`List`, `Set` 등)과 같은 데이터 그룹을 선언적이고 효율적으로 처리하기 위한 API입니다.

* 내부 반복 (Internal Iteration): 개발자가 직접 for문을 돌리는 것이 아니라, 스트림이 내부적으로 요소들을 순회하며 작업을 수행합니다.

* SQL-like 연산: 데이터베이스에서 SQL 쿼리를 작성하듯, 필터링 (`filter`), 변환 (`map`), 정렬 (`sorted`) 등의 연산을 체이닝 방식으로 처리할 수 있습니다.

### 2. Stream Data의 특징

스트림은 데이터를 담는 바구니가 아니라, 데이터가 흐르는 통로에 가깝습니다.

* 임시성 (Temporary): 처리가 끝난 스트림은 재사용이 불가능하며 즉시 소멸합니다.

* 비파괴성 (Non-destructive): 원본 데이터 (`Collection`, `Array` 등)를 변경하지 않고 복사본 형태의 스트림에서만 연산을 수행합니다.

* 데이터 저장 안 함: 스트림 자체는 요소를 저장하는 구조가 아니며, 소스로부터 요소를 전달받아 파이프라인을 통과시킬 뿐입니다.

* 병렬 처리 지원 (Parallelism): 대량의 데이터를 처리할 때 별도의 멀티 쓰레드 로직 구현 없이 `parallelStream()` 호출만으로 성능을 최적화할 수 있습니다.

### 3. Stream API 사용 단계

스트림의 작업은 `'생성 -> 가공 -> 결과'`의 명확한 단계를 거칩니다.

* Step 1. 스트림 생성 (Creation)

    * 컬렉션 (`list.stream()`), 배열 (`Arrays.stream(arr)`), 혹은 숫자 범위 등을 소스로 하여 스트림을 뽑아내는 단계입니다.

* Step 2. 중개 연산 (Intermediate Operations)

    * 스트림의 결과가 다시 스트림으로 반환되어 여러 연산을 연속적으로 연결할 수 있습니다.

    * 지연 연산(Lazy Evaluation): 최종 연산이 호출되기 전까지는 실제로 작업을 수행하지 않고 대기하는 특징이 있습니다.

    * 주요 연산
    
        * `filter` (조건식에 맞는 데이터 선별)
        
        * `map` (데이터 타입 변환)
        
        * `distinct` (중복 제거)
        
        * `limit` (개수 제한)

* Step 3. 최종 연산 (Terminal Operation)

    * 스트림 파이프라인을 닫으며 최종 결과를 산출하는 단계입니다.

    * 결과 도출
    
        * `forEach` (반복 처리)
        
        * `collect` (리스트나 셋으로 변환)
        
        * `count` (개수 세기)
        
        * `reduce` (합계 등 하나의 값으로 응축)

### 4. 예제

```Java
public static void main(String[] args) {
    List<String> datas = Arrays.asList("a", "b", "c", "d", "e");

    //step01 : 전통적인 방식
    System.out.println("*** step01 : c 데이터(equals())만 출력");
    datas.forEach(v -> {
        if (v.equals("c")) {
            System.out.println(v);
        }
    });

    //step02 : Stream API 활용
    System.out.println("*** step02 : c 데이터(equals())만 출력 + Stream API");
    datas.stream()
         .filter(v -> v.equals("c"))
         .forEach(System.out::println);

    //People 객체 스트림 처리
    List<People> datas2 = Arrays.asList(new People("연아", 30), new People("재석", 50));
    
    //? 연아라는 이름만 출력
    datas2.stream()
          .filter(p -> p.getName().equals("연아"))
          .forEach(p -> System.out.println(p.getName()));
}
```

### 5. 예제 - Stream API의 활용: 기본형 스트림 변환, 집계 연산, Optional 처리 및 내부 구조

```Java
public static void main(String[] args) {
    List<String> datas = Arrays.asList("1", "2", "3", "4", "15", "3", "3");
    
    //1. 스트림의 기본 반복 처리 (문자열 결합 확인)
    datas.stream()
         .forEach(v -> System.out.println(v + 1)); 

    //2. 수치형 스트림(Primitive Stream) 변환 및 집계
    //mapToInt: 객체 스트림을 IntStream으로 변환하여 수치 연산 (sum, max 등) 지원
    int all = datas.stream()
                   .mapToInt(Integer::parseInt)
                   .sum();
    double all2 = datas.stream()
                        .mapToDouble(Double::parseDouble)
                        .sum();
    System.out.println(all + all2);

    //3. 최종 연산 - 요소 개수 (count) 및 최댓값 (max) 추출
    //mapToInt를 거쳐 생성된 IntStream에서 요소의 개수를 반환
    System.out.println(datas.stream()
                            .mapToInt(Integer::parseInt)
                            .count());

    /* [개념] Optional: 값이 존재하지 않을 가능성을 내포하는 컨테이너
     * - OptionalInt/OptionalDouble: 기본형 (int, double) 전용 컨테이너
     */

    //max()는 데이터가 없을 경우를 대비해 OptionalInt를 반환
    System.out.println(datas.stream()
                            .mapToInt(Integer::parseInt)
                            .max()); //OptionalInt[15]
    //Optional에서 실제 값을 안전하게 꺼내기 (getAsInt() 사용)
    int data1 = datas.stream()
                     .mapToInt(Integer::parseInt)
                     .max()
                     .getAsInt();
    System.out.println(data1);

    //4. 필터링 (Filtering)과 수치 연산의 조합
    //문자열을 숫자로 변환 후, 값이 3인 요소들만 추출하여 합계 계산
    int sumData = datas.stream()
                       .mapToInt(Integer::parseInt)
                       .filter(v -> v == 3)
                       .sum();
    System.out.println(sumData);

    //5. 객체 스트림( Object Stream) 활용
    //People 객체 리스트에서 나이만 추출하여 합계 계산
    List<People> datas2 = Arrays.asList(new People("연아", 30), new People("재석", 50));
    // 메소드 참조(People::getAge)를 사용하여 가공
    int sumAge = datas2.stream()
                       .mapToInt(People::getAge)
                       .sum();
    System.out.println(sumAge);

    /* [심화] Stream API의 내부 동작 원리
     * 1. 인터페이스 설계: JDK는 Stream을 인터페이스로 정의하여 추상화된 규격을 제공
     * 2. 실질 구현체: 런타임 시 생성되는 실제 객체는 'ReferencePipeline' (Stream의 하위 클래스)
     * 3. 동적 재정의: 실행 시점에 미완성 로직 (람다식 등)을 주입받아 하위 클래스에서 모든 메소드를 재정의하여 동작
     * * 인터페이스는 직접 객체 생성이 불가하므로, 구현체를 통해 다형성을 실현
     */
    
    //6. 조건 필터링 및 최종 연산 (findFirst, forEach) 활용
    //나이가 40 이상인 첫 번째 데이터의 나이 출력
    System.out.println(datas2.stream()
                             .filter(p -> p.getAge() >= 40)
                             .findFirst()
                             .get()
                             .getAge());
    //나이가 40 이상인 모든 데이터의 나이 출력
    datas2.stream()
          .filter(p -> p.getAge() >= 40)
          .forEach(p -> System.out.println(p.getAge()));
}
```